{"meta":{"title":"群鑫璀璨","subtitle":"Technology Blog","description":"Coding Your Life","author":"HelloCoder~","url":"http://tonyhluo.top"},"pages":[{"title":"About Me","date":"2019-01-24T15:24:26.000Z","updated":"2019-01-26T14:12:35.624Z","comments":true,"path":"about/index.html","permalink":"http://tonyhluo.top/about/index.html","excerpt":"","text":"关于笔者目前在某通讯类公司做5G核心网的软件开发工作。 技术栈： 语言 ：C/C++（常用）、Python（学习中）、Shell（能应对工作）； 编辑器 ： SouceInsight、Sublime 、Vim、hexoEdit ； IDE ：VS 、Pychram； 协议： TCPIP 、HTTP； 版本管理：Git 、SVN 、Artifactory； OS ：Linux/Unix。 想玩的方向：AI、Python学校：NUAA爱好：轻摇滚、篮球、汽车、有深度的剧情片自认为是一名靠谱的团队开发者，性格开朗，有当担。对技术充满求知欲，对代码有执念！"},{"title":"Categories","date":"2019-01-24T15:17:24.000Z","updated":"2019-01-27T14:31:37.876Z","comments":true,"path":"categories/index.html","permalink":"http://tonyhluo.top/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2019-01-24T15:16:58.000Z","updated":"2019-01-27T14:31:07.373Z","comments":true,"path":"tags/index.html","permalink":"http://tonyhluo.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"python之列表","slug":"pythonList","date":"2019-02-01T13:54:39.000Z","updated":"2019-02-19T13:39:04.522Z","comments":true,"path":"2019/02/01/pythonList/","link":"","permalink":"http://tonyhluo.top/2019/02/01/pythonList/","excerpt":"前言python中列表也是一种序列式的数据类型。可以通过下标或者切片的方式去访问列表中的元素。不同于字符串的是，列表是能够保留任意数目的python对象的灵活的容器。列表不仅可以包含python的标准类型，也可以包含我们自己定义的对象作为元素，还有一点特别重要的是，不同于C语言中的数组类型，列表是可以包含不同类型的数据类型。因为列表是一种容器，所以它可以调用它所支持的一些构造函数，比如说pop、sort、empt、reverse等。下面就让我们一起学习一下列表的有关知识。","text":"前言python中列表也是一种序列式的数据类型。可以通过下标或者切片的方式去访问列表中的元素。不同于字符串的是，列表是能够保留任意数目的python对象的灵活的容器。列表不仅可以包含python的标准类型，也可以包含我们自己定义的对象作为元素，还有一点特别重要的是，不同于C语言中的数组类型，列表是可以包含不同类型的数据类型。因为列表是一种容器，所以它可以调用它所支持的一些构造函数，比如说pop、sort、empt、reverse等。下面就让我们一起学习一下列表的有关知识。 1.列表的创建和赋值&emsp;&emsp;创建列表有两种方法，一种是直接给一个列表变量赋值，只不过和给普通变量赋值不一样的是：列表是用方括号[ ]来定义的；一种是用工厂方法list() 赋值。上代码：1234567aList = [678, \"dog\", 11.13, [\"abc\", \"def\"], -9.6]print(aList) #输出[678, \"dog\", 11.13, [\"abc\", \"def\"], -9.6] #tip：列表里面可以嵌套列表的emptyList = []print(emptyList) #输出[]bList = list(\"hello\")print(bList) #输出['h', 'e', 'l', 'l', 'o'] 2.值的访问&emsp;&emsp;可以通过下标或者切片的方式去访问列表中的元素，和字符串的访问一样。上代码：12345aList = [678, \"dog\", 11.13, [\"abc\", \"def\"], -9.6]print(aList[0]) #输出678print(aList[1:5]) #输出['dog', 11.13, ['abc', 'def'], -9.6]print(aList[:3]) #输出[678, 'dog', 11.13]print(aList[3][0]) #输出'abc' 3.更新列表&emsp;&emsp;可以通过在等号的左边指定索引或者索引范围来更新列表中的一个或者几个元素，也可以通过append() 的方法来追加元素到列表中去。上代码：12345678910aList = [678, \"dog\", 11.13, [\"abc\", \"def\"], -9.6]emptyList = []aList[0] = 123print(aList) #输出[123, 'dog', 11.13, ['abc', 'def'], -9.6]aList[1:3] = [\"cat\", 2010]print(aList) #输出[123, 'cat', 2010, ['abc', 'def'], -9.6]emptyList.append(\"hava a value\")print(emptyList) #输出['hava a value']aList.append(aList[1:3])print(aList) #输出[123, 'cat', 2010, ['abc', 'def'], -9.6, ['cat', 2010]] 4.删除列表中的元素或删除自身&emsp;&emsp;如果确切的知道要删除元素的索引可以用del 语句，否则可以用remove() 方法。我们还可以通过pop() 方法来删除一个元素并从列表中返回它。上代码：1234567891011aList = [678, \"dog\", 11.13, [\"abc\", \"def\"], -9.6]del aList[1]print(aList) #输出[678, 11.13, ['abc', 'def'], -9.6]aList.remove(678)print(aList) #输出[11.13, ['abc', 'def'], -9.6]a = aList.pop()print(a) #输出-9.6，不指定索引默认删除最后一个元素print(aList) #输出[11.13, ['abc', 'def']]a = aList.pop(1)print(a) #输出['abc', 'def']print(aList) #输出[11.13] &emsp;&emsp;一般情况下，我们不需要删除一个列表对象，因为当列表对象出了作用域后会被自动析构，但是你如果想明确删除整个列表，可以用del 语句，上代码：123aList = [678, \"dog\", 11.13, [\"abc\", \"def\"], -9.6]del aListprint(aList) #注意：！！！！此时程序会报错NameError: name 'aList' is not defined，因为我们已经删除了aList，没有了aList这个对象，所以就打印不出来 5.操作符&emsp;&emsp;基本同字符串。一个特殊操作符就是列表类型操作符和列表解析。其实在python中没有专门用于列表类型的操作符。列表可以使用大部分的对象和列表序列的操作符。列表有属于自己的方法—-列表解析。上代码吧：12print([i*2 for i in [1,2,3]]); #输出[2,4,6]print([i for i in range(8) if i % 2 == 0]) #输出[0, 2, 4, 6]","categories":[{"name":"Python","slug":"Python","permalink":"http://tonyhluo.top/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://tonyhluo.top/tags/Python/"}]},{"title":"剑指offer之二进制中1的个数","slug":"codeNumberOf1","date":"2019-01-27T15:59:03.000Z","updated":"2019-01-27T16:17:27.252Z","comments":true,"path":"2019/01/27/codeNumberOf1/","link":"","permalink":"http://tonyhluo.top/2019/01/27/codeNumberOf1/","excerpt":"题目描述&emsp;&emsp;输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。","text":"题目描述&emsp;&emsp;输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 代码1234567891011121314class Solution &#123;public: int NumberOf1(int n) &#123; unsigned int flg = 1; int c = 0; while(flg)&#123; if(flg &amp; n)&#123; c++; &#125; flg = flg &lt;&lt; 1; &#125; return c; &#125;&#125;;","categories":[{"name":"Code","slug":"Code","permalink":"http://tonyhluo.top/categories/Code/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://tonyhluo.top/tags/Code/"}]},{"title":"剑指offer之矩阵覆盖","slug":"codeRectCover","date":"2019-01-27T15:58:48.000Z","updated":"2019-01-27T16:12:39.416Z","comments":true,"path":"2019/01/27/codeRectCover/","link":"","permalink":"http://tonyhluo.top/2019/01/27/codeRectCover/","excerpt":"题目描述&emsp;&emsp;我们可以用2 * 1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2* 1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？","text":"题目描述&emsp;&emsp;我们可以用2 * 1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2* 1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 代码123456789101112131415161718//就是斐波那契数列class Solution &#123;public: int rectCover(int n) &#123; if(0 == n || 1 == n || 2 == n)&#123; return n; &#125; int FibOne = 2; int FibTwo = 1; int FibN = 0; for(int i = 3; i &lt;= n; ++i)&#123; FibN = FibOne + FibTwo; FibTwo = FibOne; FibOne = FibN; &#125; return FibN; &#125;&#125;;","categories":[{"name":"Code","slug":"Code","permalink":"http://tonyhluo.top/categories/Code/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://tonyhluo.top/tags/Code/"}]},{"title":"剑指offer之变态跳台阶","slug":"codeJumpFloorII","date":"2019-01-27T15:58:24.000Z","updated":"2019-01-27T16:05:32.913Z","comments":true,"path":"2019/01/27/codeJumpFloorII/","link":"","permalink":"http://tonyhluo.top/2019/01/27/codeJumpFloorII/","excerpt":"题目描述&emsp;&emsp;一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。","text":"题目描述&emsp;&emsp;一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 代码123456class Solution &#123;public: int jumpFloorII(int number) &#123; return 1&lt;&lt;(number-1); &#125;&#125;;","categories":[{"name":"Code","slug":"Code","permalink":"http://tonyhluo.top/categories/Code/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://tonyhluo.top/tags/Code/"}]},{"title":"剑指offer之跳台阶","slug":"codeJumpFloor","date":"2019-01-27T15:57:58.000Z","updated":"2019-01-27T16:03:54.537Z","comments":true,"path":"2019/01/27/codeJumpFloor/","link":"","permalink":"http://tonyhluo.top/2019/01/27/codeJumpFloor/","excerpt":"题目描述&emsp;&emsp;一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。","text":"题目描述&emsp;&emsp;一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 代码1234567891011121314151617class Solution &#123;public: int jumpFloor(int n) &#123; if(0 == n || 1 == n || 2 == n)&#123; return n; &#125; int jumpOne = 2; int jumpTwo = 1; int jumpN = 0; for(int i = 3; i &lt;= n; ++i)&#123; jumpN = jumpOne + jumpTwo; jumpTwo = jumpOne; jumpOne = jumpN; &#125; return jumpN; &#125;&#125;;","categories":[{"name":"Code","slug":"Code","permalink":"http://tonyhluo.top/categories/Code/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://tonyhluo.top/tags/Code/"}]},{"title":"剑指offer之斐波那契数列","slug":"codeFibonacci","date":"2019-01-27T15:57:31.000Z","updated":"2019-01-27T16:01:00.452Z","comments":true,"path":"2019/01/27/codeFibonacci/","link":"","permalink":"http://tonyhluo.top/2019/01/27/codeFibonacci/","excerpt":"题目描述&emsp;&emsp;大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。&emsp;&emsp;n&lt;=39","text":"题目描述&emsp;&emsp;大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。&emsp;&emsp;n&lt;=39 代码1234567891011121314151617class Solution &#123;public: int Fibonacci(int n) &#123; if(0 == n || 1 == n)&#123; return n; &#125; int FibOne = 1; int FibTwo = 0; int FibN = 0; for(int i = 2; i &lt;= n; ++i)&#123; FibN = FibOne + FibTwo; FibTwo = FibOne; FibOne = FibN; &#125; return FibN; &#125;&#125;;","categories":[{"name":"Code","slug":"Code","permalink":"http://tonyhluo.top/categories/Code/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://tonyhluo.top/tags/Code/"}]},{"title":"剑指offer之旋转数组的最小数字","slug":"codeMinNumberInRotateArray","date":"2019-01-27T15:50:51.000Z","updated":"2019-01-27T15:55:49.703Z","comments":true,"path":"2019/01/27/codeMinNumberInRotateArray/","link":"","permalink":"http://tonyhluo.top/2019/01/27/codeMinNumberInRotateArray/","excerpt":"题目描述&emsp;&emsp;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。","text":"题目描述&emsp;&emsp;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123;public: int minOrder(vector&lt;int&gt; rotateArray) &#123; int val = rotateArray[0]; for(unsigned int i = 1; i &lt;= rotateArray.size() - 1; ++i) &#123; if(val &gt; rotateArray[i]) &#123; val = rotateArray[i]; &#125; &#125; return val; &#125; int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123; if(rotateArray.empty()) &#123; return 0; &#125; int index1 = 0; int index2 = rotateArray.size()-1; int indexMid = index1; while(rotateArray[index1] &gt;= rotateArray[index2]) &#123; if(1 == index2 - index1) &#123; indexMid = index2; break; &#125; indexMid = (index1+index2)/2; if(rotateArray[indexMid] == rotateArray[index1] &amp;&amp; rotateArray[index1] == rotateArray[index2]) &#123; return minOrder(rotateArray); &#125; if(rotateArray[indexMid] &lt;= rotateArray[index1]) &#123; index2 = indexMid; &#125; if(rotateArray[indexMid] &gt;= rotateArray[index1]) &#123; index1 = indexMid; &#125; &#125; return rotateArray[indexMid]; &#125;&#125;;","categories":[{"name":"Code","slug":"Code","permalink":"http://tonyhluo.top/categories/Code/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://tonyhluo.top/tags/Code/"}]},{"title":"剑指offer之用两个栈实现队列","slug":"codeTwoStack","date":"2019-01-27T15:44:56.000Z","updated":"2019-01-27T15:48:18.777Z","comments":true,"path":"2019/01/27/codeTwoStack/","link":"","permalink":"http://tonyhluo.top/2019/01/27/codeTwoStack/","excerpt":"题目描述&emsp;&emsp;用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。","text":"题目描述&emsp;&emsp;用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 代码1234567891011121314151617181920212223242526272829303132class Solution&#123;public: void push(int node) &#123; stack1.push(node); &#125; int pop() &#123; while(!stack1.empty()) &#123; int headVal = stack1.top(); stack2.push(headVal); stack1.pop(); &#125; int headVal = stack2.top(); stack2.pop(); while(!stack2.empty()) &#123; int headVal = stack2.top(); stack1.push(headVal); stack2.pop(); &#125; return headVal; &#125;private: stack&lt;int&gt; stack1; stack&lt;int&gt; stack2;&#125;;","categories":[{"name":"Code","slug":"Code","permalink":"http://tonyhluo.top/categories/Code/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://tonyhluo.top/tags/Code/"}]},{"title":"剑指offer之重建二叉树","slug":"codeReConstructBinaryTree","date":"2019-01-27T15:16:40.000Z","updated":"2019-01-27T15:30:47.291Z","comments":true,"path":"2019/01/27/codeReConstructBinaryTree/","link":"","permalink":"http://tonyhluo.top/2019/01/27/codeReConstructBinaryTree/","excerpt":"题目描述&emsp;&emsp;输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。","text":"题目描述&emsp;&emsp;输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123; if(0 == pre.size() || 0 == vin.size()) return NULL; vector&lt;int&gt; pre_left, pre_right, vin_left, vin_right; int cursor = 0; int rootVal = pre[0]; TreeNode* root = new TreeNode(0); root-&gt;val = rootVal; if(pre.size() == 1 &amp;&amp; vin.size() == 1 &amp;&amp; pre[0] == vin[0]) return root; for(int i = 0; i &lt; vin.size(); ++i) &#123; if(vin[i] == rootVal) &#123; cursor = i; break; &#125; &#125; for(int i = 0; i &lt; cursor; ++i) &#123; vin_left.push_back(vin[i]); pre_left.push_back(pre[i+1]); &#125; for(int i = cursor + 1; i &lt; vin.size(); ++i) &#123; vin_right.push_back(vin[i]); pre_right.push_back(pre[i]); &#125; root-&gt;left = reConstructBinaryTree(pre_left,vin_left); root-&gt;right = reConstructBinaryTree(pre_right,vin_right); return root; &#125;&#125;;","categories":[{"name":"Code","slug":"Code","permalink":"http://tonyhluo.top/categories/Code/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://tonyhluo.top/tags/Code/"}]},{"title":"剑指offer之从尾到头打印链表","slug":"codePrintList","date":"2019-01-27T14:50:48.000Z","updated":"2019-01-27T15:15:46.578Z","comments":true,"path":"2019/01/27/codePrintList/","link":"","permalink":"http://tonyhluo.top/2019/01/27/codePrintList/","excerpt":"题目描述&emsp;&emsp;输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。","text":"题目描述&emsp;&emsp;输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 代码123456789101112131415161718192021222324252627282930/*** struct ListNode &#123;* int val;* struct ListNode *next;* ListNode(int x) :* val(x), next(NULL) &#123;* &#125;* &#125;;*/class Solution &#123;public: vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123; vector&lt;int&gt; vec; if(NULL == head) return vec; ListNode* node = head; while(NULL != node) &#123; vec.push_back(node-&gt;val); node = node-&gt;next; &#125; vector&lt;int&gt; arrayRever; vector&lt;int&gt;::reverse_iterator riter; for (riter = vec.rbegin(); riter != vec.rend(); riter++) &#123; arrayRever.push_back(*riter); &#125; return arrayRever; &#125;&#125;;","categories":[{"name":"Code","slug":"Code","permalink":"http://tonyhluo.top/categories/Code/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://tonyhluo.top/tags/Code/"}]},{"title":"剑指offer之替换空格","slug":"codeSpace","date":"2019-01-27T14:39:32.000Z","updated":"2019-01-27T14:45:36.502Z","comments":true,"path":"2019/01/27/codeSpace/","link":"","permalink":"http://tonyhluo.top/2019/01/27/codeSpace/","excerpt":"题目描述&emsp;&emsp;请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。","text":"题目描述&emsp;&emsp;请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 代码12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: void replaceSpace(char *str,int length) &#123; if(NULL == str || length &lt;= 0) &#123; return; &#125; int blankNum = 0; for(int i = 0;i &lt; strlen(str); ++i) &#123; if(str[i] == 32) &#123; ++blankNum; &#125; &#125; int newLen = strlen(str) + 2 * blankNum; int originalIdex = strlen(str); int newIdex = newLen; while(originalIdex &gt;= 0 &amp;&amp; newIdex &gt; originalIdex) &#123; if(str[originalIdex] == 32) &#123; str[newIdex--] = 48; str[newIdex--] = 50; str[newIdex--] = 37; &#125; else &#123; str[newIdex--] = str[originalIdex]; &#125; --originalIdex; &#125; &#125;&#125;;","categories":[{"name":"Code","slug":"Code","permalink":"http://tonyhluo.top/categories/Code/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://tonyhluo.top/tags/Code/"}]},{"title":"python之字符串","slug":"pythonString","date":"2019-01-26T12:07:39.000Z","updated":"2019-02-01T14:12:09.373Z","comments":true,"path":"2019/01/26/pythonString/","link":"","permalink":"http://tonyhluo.top/2019/01/26/pythonString/","excerpt":"前言 字符串类型是python里面最长见的数据类型。记住一点python里面的单引号和双引号的作用是相同的，这是python不同于其他语言的一点。比如说在C语言里面用单引号来标识字符，用双引号来标识字符串，但是在python里面没有字符这个概念，这有可能是单引号和双引号的作用是相同的另外一个原因吧。字符串是不可变的类型，意味着改变一个字符串的元素需要新建一个新的字符串。字符串中的字符可以通过切片操作顺序的访问。","text":"前言 字符串类型是python里面最长见的数据类型。记住一点python里面的单引号和双引号的作用是相同的，这是python不同于其他语言的一点。比如说在C语言里面用单引号来标识字符，用双引号来标识字符串，但是在python里面没有字符这个概念，这有可能是单引号和双引号的作用是相同的另外一个原因吧。字符串是不可变的类型，意味着改变一个字符串的元素需要新建一个新的字符串。字符串中的字符可以通过切片操作顺序的访问。 1.字符串的创建和赋值&emsp;&emsp;创建字符串就和创建其他变量一样简单，当然你也可以用把 str() 作为工厂方法创建一个字符串并把它赋值给一个变量，直接上代码：12aString = \"You are my friend\"bString = str(\"You are my friend too\") 2.值的访问&emsp;&emsp;前言中已经提到，python没有字符 的概念，所以替换它的是长度为1的字符串，可以用[i]、[i:]、[:i]、[i:j] 的方式来访问字符串中的某个值或者说某一个子串，i 和 j 分别代表索引，python中字符串索引和其他语言也是一样的，下标从0开始。如下：12345aString = \"You are my friend\"aString[0] #对应于\"Y\"aString[1:] #对应于\"ou are my friend\"aString[:5] #对应于\"You a\"aString[2:6] #对应于\"u ar\" 3.改变字符串&emsp;&emsp;可以通过给一个字符串赋值的方式来更新 一个已有的字符串。上代码：123aString = \"You are my friend\"aString = aString[:11] + \"classmates\" #对应于\"You are my classmates\"aString = \"Yes,you too!\" #对应于\"Yes,you too!\" 4.删除字符串&emsp;&emsp;首先，字符串是不可变 的，所以你不能删除一个字符串里的某个字符，能做的只是清空一个空字符串，或者把把不需要的字符串剔除再拼接，上代码：123aString = \"You are my friend\"aString = aString[:5] + aString[6:] #删除\"r\"print(aString) #输出 \"You ae my friend\" 5.字符串操作符5.1 标准操作符&emsp;&emsp;字符串操作符有标准类型的操作符，比如：&lt;、&gt;、==、!=，这些和其他语言的比较操作符一样，是按照ASCII值的大小来比较，在这里就不细究了。 5.2 序列操作符&emsp;&emsp;字符串也有序列操作符切片，关于切片我会专门做一个专题来讲。 5.3 成员操作符&emsp;&emsp;字符串也有自己的成员操作符in和not in。上代码：12345aString = \"py\"bString = \"pt\"cString = \"python\"print(aString in cString) #Tureprint(bString in cString) #False 5.4 连接符（+）&emsp;&emsp;和C++ STL中的string一样，python也有连接操作符“+” ，我们可以通过这种连接操作符来从原有的字符串获得一个新的字符串。上代码：1234aString = \"I am a\" + \"coder\"print(aString) #输出\"I am acoder\"aString = \"I am a\" + \" \" + \"coder\"print(aString) #输出\"I am a coder\" 6.独特特性6.1 三引号&emsp;&emsp;三引号允许字符串夸多行显示，字符串中可以包含换行符，制表符等其他特殊字符。上代码：123456789101112aString = '''Iamacoder'''print(aString)#输出如下：###################I#am#a#coder################# 6.2 不变性&emsp;&emsp;前言中提过，字符串是一种不可变的数据类型，也就是说它的值不能被改变或者被修改。所以如果想改变一个字符串，你就要新创建一个字符串。可是，在实际应用中没有想象中的那么复杂，原因是python为你管理内存，你根本不需要关心到底发生了什么，你每次变更一个字符串时，python都会为你分配一个新的字符串。&emsp;&emsp;我们可以用 id() 函数来验证一下上面所说的，什么叫id() 函数？你可以把它理解为内存地址 。上代码：123456aString = \"You are my friend\"id1 = id(aString)print(id1) #输出36610384aString += \"too\"id2 = id(aString)print(id2) #输出36698848 有没有看到？修改前后身份变啦~~ 7.一个注意点&emsp;&emsp;python字符串中不是通过NUL或者’\\0’来结束的！！！在C风格编程语言中，一个主要的原因是你访问了一个字符串后面本不属于你的空间，发生这种情况原因是你没有在字符串末尾添加NUL或’\\0’。在python中就没有这种情况了，python字符串不是以NUL来结束的，所以你不要担心有没有添加终止符。字符串中只包含你所定义的内容，其余都没有。 &emsp;&emsp;上面的内容就是一些python字符串的基本应用，很简单吧，可是字符串在其他语言中，比如在C语言中可没这么简单，一些有关字符串的操作运用了C标准库函数，比如memcpy()，strncpy()等等，这些都必须要对内存中字符串的形态要有所了解，而python的字符串你只管用就行了。","categories":[{"name":"Python","slug":"Python","permalink":"http://tonyhluo.top/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://tonyhluo.top/tags/Python/"}]},{"title":"关于博客","slug":"firstblog","date":"2019-01-23T16:20:21.000Z","updated":"2019-01-26T16:27:50.087Z","comments":true,"path":"2019/01/24/firstblog/","link":"","permalink":"http://tonyhluo.top/2019/01/24/firstblog/","excerpt":"","text":"&emsp;&emsp;折腾了两天，属于自己的Blog终于有个雏形了，在整个过程学到了一些前端技术，还是有所收获的。 &emsp;&emsp;此站点是我平时记录一些技术文章的地方，为什么要写博客？主要有以下几点： 1.平时看的东西比较杂，特别是技术上的一些书和文章，希望能在blog上收敛，起到一个归总的作用； 2.说实话，记性不太好，希望能通过写blog起到一个巩固的作用，俗话说好记性不如烂笔头； 3.我相信通过写blog可以把书看薄吧。 &emsp;&emsp;希望这是一个好的开始，让我们在技术的世界里遨游吧。","categories":[{"name":"Essay","slug":"Essay","permalink":"http://tonyhluo.top/categories/Essay/"}],"tags":[{"name":"Essay","slug":"Essay","permalink":"http://tonyhluo.top/tags/Essay/"}]}]}