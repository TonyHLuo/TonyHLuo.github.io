{"meta":{"title":"群鑫璀璨","subtitle":"Technology Blog","description":"Coding Your Life","author":"HelloCoder~","url":"http://tonyhluo.top"},"pages":[{"title":"About Me","date":"2019-01-24T15:24:26.000Z","updated":"2019-01-26T14:12:35.624Z","comments":true,"path":"about/index.html","permalink":"http://tonyhluo.top/about/index.html","excerpt":"","text":"关于笔者目前在某通讯类公司做5G核心网的软件开发工作。 技术栈： 语言 ：C/C++（常用）、Python（学习中）、Shell（能应对工作）； 编辑器 ： SouceInsight、Sublime 、Vim、hexoEdit ； IDE ：VS 、Pychram； 协议： TCPIP 、HTTP； 版本管理：Git 、SVN 、Artifactory； OS ：Linux/Unix。 想玩的方向：AI、Python学校：NUAA爱好：轻摇滚、篮球、汽车、有深度的剧情片自认为是一名靠谱的团队开发者，性格开朗，有当担。对技术充满求知欲，对代码有执念！"},{"title":"Tags","date":"2019-01-24T15:16:58.000Z","updated":"2019-01-27T14:31:07.373Z","comments":true,"path":"tags/index.html","permalink":"http://tonyhluo.top/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2019-01-24T15:17:24.000Z","updated":"2019-01-27T14:31:37.876Z","comments":true,"path":"categories/index.html","permalink":"http://tonyhluo.top/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"剑指offer之重建二叉树","slug":"codeReConstructBinaryTree","date":"2019-01-27T15:16:40.000Z","updated":"2019-01-27T15:30:47.291Z","comments":true,"path":"2019/01/27/codeReConstructBinaryTree/","link":"","permalink":"http://tonyhluo.top/2019/01/27/codeReConstructBinaryTree/","excerpt":"题目描述&emsp;&emsp;输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。","text":"题目描述&emsp;&emsp;输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123; if(0 == pre.size() || 0 == vin.size()) return NULL; vector&lt;int&gt; pre_left, pre_right, vin_left, vin_right; int cursor = 0; int rootVal = pre[0]; TreeNode* root = new TreeNode(0); root-&gt;val = rootVal; if(pre.size() == 1 &amp;&amp; vin.size() == 1 &amp;&amp; pre[0] == vin[0]) return root; for(int i = 0; i &lt; vin.size(); ++i) &#123; if(vin[i] == rootVal) &#123; cursor = i; break; &#125; &#125; for(int i = 0; i &lt; cursor; ++i) &#123; vin_left.push_back(vin[i]); pre_left.push_back(pre[i+1]); &#125; for(int i = cursor + 1; i &lt; vin.size(); ++i) &#123; vin_right.push_back(vin[i]); pre_right.push_back(pre[i]); &#125; root-&gt;left = reConstructBinaryTree(pre_left,vin_left); root-&gt;right = reConstructBinaryTree(pre_right,vin_right); return root; &#125;&#125;;","categories":[{"name":"Code","slug":"Code","permalink":"http://tonyhluo.top/categories/Code/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://tonyhluo.top/tags/Code/"}]},{"title":"剑指offer之从尾到头打印链表","slug":"codePrintList","date":"2019-01-27T14:50:48.000Z","updated":"2019-01-27T15:15:46.578Z","comments":true,"path":"2019/01/27/codePrintList/","link":"","permalink":"http://tonyhluo.top/2019/01/27/codePrintList/","excerpt":"题目描述&emsp;&emsp;输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。","text":"题目描述&emsp;&emsp;输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 代码123456789101112131415161718192021222324252627282930/*** struct ListNode &#123;* int val;* struct ListNode *next;* ListNode(int x) :* val(x), next(NULL) &#123;* &#125;* &#125;;*/class Solution &#123;public: vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123; vector&lt;int&gt; vec; if(NULL == head) return vec; ListNode* node = head; while(NULL != node) &#123; vec.push_back(node-&gt;val); node = node-&gt;next; &#125; vector&lt;int&gt; arrayRever; vector&lt;int&gt;::reverse_iterator riter; for (riter = vec.rbegin(); riter != vec.rend(); riter++) &#123; arrayRever.push_back(*riter); &#125; return arrayRever; &#125;&#125;;","categories":[{"name":"Code","slug":"Code","permalink":"http://tonyhluo.top/categories/Code/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://tonyhluo.top/tags/Code/"}]},{"title":"剑指offer之替换空格","slug":"codeSpace","date":"2019-01-27T14:39:32.000Z","updated":"2019-01-27T14:45:36.502Z","comments":true,"path":"2019/01/27/codeSpace/","link":"","permalink":"http://tonyhluo.top/2019/01/27/codeSpace/","excerpt":"题目描述&emsp;&emsp;请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。","text":"题目描述&emsp;&emsp;请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 代码12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: void replaceSpace(char *str,int length) &#123; if(NULL == str || length &lt;= 0) &#123; return; &#125; int blankNum = 0; for(int i = 0;i &lt; strlen(str); ++i) &#123; if(str[i] == 32) &#123; ++blankNum; &#125; &#125; int newLen = strlen(str) + 2 * blankNum; int originalIdex = strlen(str); int newIdex = newLen; while(originalIdex &gt;= 0 &amp;&amp; newIdex &gt; originalIdex) &#123; if(str[originalIdex] == 32) &#123; str[newIdex--] = 48; str[newIdex--] = 50; str[newIdex--] = 37; &#125; else &#123; str[newIdex--] = str[originalIdex]; &#125; --originalIdex; &#125; &#125;&#125;;","categories":[{"name":"Code","slug":"Code","permalink":"http://tonyhluo.top/categories/Code/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://tonyhluo.top/tags/Code/"}]},{"title":"python之字符串","slug":"pythonString","date":"2019-01-26T12:07:39.000Z","updated":"2019-01-27T14:31:41.349Z","comments":true,"path":"2019/01/26/pythonString/","link":"","permalink":"http://tonyhluo.top/2019/01/26/pythonString/","excerpt":"前言 字符串类型是python里面最长见的数据类型。记住一点python里面的单引号和双引号的作用是相同的，这是python不同于其他语言的一点。比如说在C语言里面用单引号来标识字符，用双引号来标识字符串，但是在python里面没有字符这个概念，这有可能是单引号和双引号的作用是相同的另外一个原因吧。字符串是不可变的类型，意味着改变一个字符串的元素需要新建一个新的字符串。字符串中的字符可以通过切片操作顺序的访问。","text":"前言 字符串类型是python里面最长见的数据类型。记住一点python里面的单引号和双引号的作用是相同的，这是python不同于其他语言的一点。比如说在C语言里面用单引号来标识字符，用双引号来标识字符串，但是在python里面没有字符这个概念，这有可能是单引号和双引号的作用是相同的另外一个原因吧。字符串是不可变的类型，意味着改变一个字符串的元素需要新建一个新的字符串。字符串中的字符可以通过切片操作顺序的访问。 1.字符串的创建和赋值&emsp;&emsp;创建字符串就和创建其他变量一样简单，当然你也可以用把 str() 作为工厂方法创建一个字符串并把它赋值给一个变量，直接上代码：12aString = \"You are my friend\"bString = str(\"You are my friend too\") 2.值的访问&emsp;&emsp;前言中已经提到，python没有字符 的概念，所以替换它的是长度为1的字符串，可以用[i]、[i:]、[:i]、[i:j] 的方式来访问字符串中的某个值或者说某一个子串，i 和 j 分别代表索引，python中字符串索引和其他语言也是一样的，下标从0开始。如下：12345aString = \"You are my friend\"aString[0] #对应于\"Y\"aString[1:] #对应于\"ou are my friend\"aString[:5] #对应于\"You a\"aString[2:6] #对应于\"u ar\" 3.改变字符串&emsp;&emsp;可以通过给一个字符串赋值的方式来更新 一个已有的字符串。上代码：123aString = \"You are my friend\"aString = aString[:11] + \"classmates\" #对应于\"You are my classmates\"aString = \"Yes,you too!\" #对应于\"Yes,you too!\" 4.删除字符串&emsp;&emsp;首先，字符串是不可变 的，所以你不能删除一个字符串里的某个字符，能做的只是清空一个空字符串，或者把把不需要的字符串剔除再拼接，上代码：123aString = \"You are my friend\"aString = aString[:5] + aString[6:] #删除\"r\"print(aString) #输出 \"You ae my friend\" 5.字符串操作符5.1 标准操作符&emsp;&emsp;字符串操作符有标准类型的操作符，比如：&lt;、&gt;、==、!=，这些和其他语言的比较操作符一样，是按照ASCII值的大小来比较，在这里就不细究了。 5.2 序列操作符&emsp;&emsp;字符串也有序列操作符切片，关于切片我会专门做一个专题来讲。 5.3 成员操作符&emsp;&emsp;字符串也有自己的成员操作符in和not in。上代码：12345aString = \"py\"bString = \"pt\"cString = \"python\"print(aString in cString) #Tureprint(bString in cString) #False 5.4 连接符（+）&emsp;&emsp;和C++ STL中的string一样，python也有连接操作符“+” ，我们可以通过这种连接操作符来从原有的字符串获得一个新的字符串。上代码：1234aString = \"I am a\" + \"coder\"print(aString) #输出\"I am acoder\"aString = \"I am a\" + \" \" + \"coder\"print(aString) #输出\"I am a coder\" 6.独特特性6.1 三引号&emsp;&emsp;三引号允许字符串夸多行显示，字符串中可以包含换行符，制表符等其他特殊字符。上代码：123456789101112aString = '''Iamacoder'''print(aString)#输出如下：###################I#am#a#coder################# 6.2 不变性&emsp;&emsp;前言中提过，字符串是一种不可变的数据类型，也就是说它的值不能被改变或者被修改。所以如果想改变一个字符串，你就要新创建一个字符串。可是，在实际应用中没有想象中的那么复杂，原因是python为你管理内存，你根本不需要关心到底发生了什么，你每次变更一个字符串时，python都会为你分配一个新的字符串。&emsp;&emsp;我们可以用 id() 函数来验证一下上面所说的，什么叫id() 函数？你可以把它理解为内存地址 。上代码：123456aString = \"You are my friend\"id1 = id(aString)print(id1) #输出36610384aString += \"too\"id2 = id(aString)print(id2) #输出36698848 有没有看到？修改前后身份变啦~~ 7.一个注意点&emsp;&emsp;python字符串中不是通过NUL或者’\\0’来结束的！！！在C风格编程语言中，一个主要的原因是你访问了一个字符串后面本不属于你的空间，发生这种情况原因是你没有在字符串末尾添加NUL或’\\0’。在python中就没有这种情况了，python字符串不是以NUL来结束的，所以你不要担心有没有添加终止符。字符串中只包含你所定义的内容，其余都没有。 &emsp;&emsp;上面的内容就是一些python字符串的基本应用，很简单吧，可是字符串在其他语言中，比如在C语言中可没这么简单，一些有关字符串的操作运用了C标准库函数，比如memcpy()，strncpy()等等，这些都必须要对内存中字符串的形态要有所了解，而python的字符串你只管用就行了。","categories":[{"name":"Python","slug":"Python","permalink":"http://tonyhluo.top/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://tonyhluo.top/tags/Python/"}]},{"title":"关于博客","slug":"firstblog","date":"2019-01-23T16:20:21.000Z","updated":"2019-01-26T16:27:50.087Z","comments":true,"path":"2019/01/24/firstblog/","link":"","permalink":"http://tonyhluo.top/2019/01/24/firstblog/","excerpt":"","text":"&emsp;&emsp;折腾了两天，属于自己的Blog终于有个雏形了，在整个过程学到了一些前端技术，还是有所收获的。 &emsp;&emsp;此站点是我平时记录一些技术文章的地方，为什么要写博客？主要有以下几点： 1.平时看的东西比较杂，特别是技术上的一些书和文章，希望能在blog上收敛，起到一个归总的作用； 2.说实话，记性不太好，希望能通过写blog起到一个巩固的作用，俗话说好记性不如烂笔头； 3.我相信通过写blog可以把书看薄吧。 &emsp;&emsp;希望这是一个好的开始，让我们在技术的世界里遨游吧。","categories":[{"name":"Essay","slug":"Essay","permalink":"http://tonyhluo.top/categories/Essay/"}],"tags":[{"name":"Essay","slug":"Essay","permalink":"http://tonyhluo.top/tags/Essay/"}]}]}